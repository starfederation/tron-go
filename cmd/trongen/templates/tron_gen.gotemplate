// Code generated by trongen; DO NOT EDIT.

package {{.PackageName}}

import (
{{- range .Imports}}
	{{.}}
{{- end}}
)

{{range .Structs}}
func {{.Name}}FromTRON(doc []byte) (*{{.Name}}TRON, error) {
	if len(doc) == 0 {
		return nil, trongenProxyErrNoData
	}
	root, err := trongenProxyMapRoot(doc)
	if err != nil {
		return nil, err
	}
	return &{{.Name}}TRON{doc: doc, root: root}, nil
}

// {{.Name}}TRON lazily converts between TRON documents and {{.Name}}.
type {{.Name}}TRON struct {
	doc  []byte
	root uint32
}

func (v *{{.Name}}) FullCopyToTRON() (*{{.Name}}TRON, error) {
	doc, err := trongenProxyMarshal(v)
	if err != nil {
		return nil, err
	}
	return {{.Name}}FromTRON(doc)
}

func (t *{{.Name}}TRON) FullCopyTo{{.Name}}(out *{{.Name}}) error {
	if len(t.doc) == 0 {
		return trongenProxyErrNoData
	}
	doc, err := trongenProxyDocForRoot(t.doc, t.root)
	if err != nil {
		return err
	}
	return trongenProxyUnmarshal(doc, out)
}

{{ $structName := .Name }}
{{range .Fields}}
func (t *{{$structName}}TRON) {{.Name}}() ({{.ReturnType}}, bool, error) {
	var out {{.ReturnType}}
	if len(t.doc) == 0 {
		return out, false, trongenProxyErrNoData
	}
	val, ok, err := trongenProxyGetFieldValue(t.doc, t.root, "{{.JSONName}}", {{.HashHex}})
	if err != nil || !ok {
		return out, ok, err
	}
	{{- if .IsProxy}}
	if val.Type != {{$.TronPrefix}}TypeMap {
		return out, false, trongenProxyErrFieldNotMap
	}
	out = &{{.ProxyType}}{doc: t.doc, root: val.Offset}
	return out, true, nil
	{{- else}}
	if err := trongenProxyUnmarshalValue(t.doc, val, &out); err != nil {
		return out, false, err
	}
	return out, true, nil
	{{- end}}
}

func (t *{{$structName}}TRON) Set{{.Name}}({{- if .SetterVariadic}}v ...{{.SetterType}}{{- else}}v {{.SetterType}}{{- end}}) error {
	doc, root, err := trongenProxySetFieldValue(t.doc, t.root, "{{.JSONName}}", {{.HashHex}}, v)
	if err != nil {
		return err
	}
	t.doc = doc
	t.root = root
	return nil
}

{{end}}
func (t *{{.Name}}TRON) TRON() ([]byte, error) {
	if len(t.doc) == 0 {
		return nil, trongenProxyErrNoData
	}
	return trongenProxyDocForRoot(t.doc, t.root)
}

func (t *{{.Name}}TRON) Raw() []byte {
	return t.doc
}

{{end}}

{{if .IsRootPackage}}
var (
	trongenProxyErrNoData     = errors.New("trongen: no data")
	trongenProxyErrNotTree    = errors.New("trongen: document is not a tree")
	trongenProxyErrRootNotMap = errors.New("trongen: root is not a map")
	trongenProxyErrFieldNotMap = errors.New("trongen: field is not a map")
)

func trongenProxyMapRoot(doc []byte) (uint32, error) {
	if _, err := DetectDocType(doc); err != nil {
		return 0, err
	}
	tr, err := ParseTrailer(doc)
	if err != nil {
		return 0, err
	}
	root, err := DecodeValueAt(doc, tr.RootOffset)
	if err != nil {
		return 0, err
	}
	if root.Type != TypeMap {
		return 0, trongenProxyErrRootNotMap
	}
	return tr.RootOffset, nil
}

func trongenProxyDocForRoot(doc []byte, root uint32) ([]byte, error) {
	if len(doc) == 0 {
		return nil, trongenProxyErrNoData
	}
	tr, err := ParseTrailer(doc)
	if err == nil && tr.RootOffset == root {
		return doc, nil
	}
	builder, _, err := NewBuilderFromDocument(doc)
	if err != nil {
		return nil, err
	}
	return builder.BytesWithTrailer(root, root), nil
}

func trongenProxyGetFieldValue(doc []byte, root uint32, key string, hash uint32) (Value, bool, error) {
	header, _, err := NodeSliceAt(doc, root)
	if err != nil {
		return Value{}, false, err
	}
	if header.KeyType != KeyMap {
		return Value{}, false, trongenProxyErrRootNotMap
	}
	return MapGetHashed(doc, root, []byte(key), hash)
}

func trongenProxySetFieldValue(doc []byte, root uint32, key string, hash uint32, value any) ([]byte, uint32, error) {
	if len(doc) == 0 {
		return nil, 0, trongenProxyErrNoData
	}
	builder, _, err := NewBuilderFromDocument(doc)
	if err != nil {
		return nil, 0, err
	}
	header, _, err := NodeSliceAt(doc, root)
	if err != nil {
		return nil, 0, err
	}
	if header.KeyType != KeyMap {
		return nil, 0, trongenProxyErrRootNotMap
	}
	val, err := trongenProxyValueFromGo(builder, value)
	if err != nil {
		return nil, 0, err
	}
	newRoot, _, err := MapSetNodeHashed(builder, root, []byte(key), hash, val)
	if err != nil {
		return nil, 0, err
	}
	return builder.BytesWithTrailer(newRoot, root), newRoot, nil
}

func trongenProxyMarshal(v any) ([]byte, error) {
	data, err := stdjson.Marshal(v)
	if err != nil {
		return nil, err
	}
	return FromJSON(data)
}

func trongenProxyUnmarshal(doc []byte, out any) error {
	if out == nil {
		return errors.New("nil target")
	}
	value, err := trongenProxyDocumentToAny(doc)
	if err != nil {
		return err
	}
	data, err := stdjson.Marshal(value)
	if err != nil {
		return err
	}
	return stdjson.Unmarshal(data, out)
}

func trongenProxyUnmarshalValue(doc []byte, v Value, out any) error {
	if out == nil {
		return errors.New("nil target")
	}
	value, err := valueToAny(doc, v)
	if err != nil {
		return err
	}
	data, err := stdjson.Marshal(value)
	if err != nil {
		return err
	}
	return stdjson.Unmarshal(data, out)
}

func trongenProxyValueFromGo(builder *Builder, v any) (Value, error) {
	if builder == nil {
		return Value{}, errors.New("nil builder")
	}
	doc, err := trongenProxyMarshal(v)
	if err != nil {
		return Value{}, err
	}
	if _, err := DetectDocType(doc); err != nil {
		return Value{}, err
	}
	tr, err := ParseTrailer(doc)
	if err != nil {
		return Value{}, err
	}
	root, err := DecodeValueAt(doc, tr.RootOffset)
	if err != nil {
		return Value{}, err
	}
	return CloneValueFromDoc(doc, root, builder)
}

func trongenProxyDocumentToAny(doc []byte) (any, error) {
	if _, err := DetectDocType(doc); err != nil {
		return nil, err
	}
	tr, err := ParseTrailer(doc)
	if err != nil {
		return nil, err
	}
	root, err := DecodeValueAt(doc, tr.RootOffset)
	if err != nil {
		return nil, err
	}
	return valueToAny(doc, root)
}
{{else}}
var (
	trongenProxyErrNoData      = tronruntime.ErrTronProxyNoData
	trongenProxyErrFieldNotMap = tronruntime.ErrTronProxyFieldNotMap
)

func trongenProxyMapRoot(doc []byte) (uint32, error) {
	return tronruntime.MapRoot(doc)
}

func trongenProxyDocForRoot(doc []byte, root uint32) ([]byte, error) {
	return tronruntime.DocForRoot(doc, root)
}

func trongenProxyGetFieldValue(doc []byte, root uint32, key string, hash uint32) ({{.TronPrefix}}Value, bool, error) {
	return tronruntime.GetFieldValue(doc, root, key, hash)
}

func trongenProxySetFieldValue(doc []byte, root uint32, key string, hash uint32, value any) ([]byte, uint32, error) {
	return tronruntime.SetFieldValue(doc, root, key, hash, value)
}

func trongenProxyMarshal(v any) ([]byte, error) {
	return tronjson.Marshal(v)
}

func trongenProxyUnmarshal(doc []byte, out any) error {
	return tronjson.Unmarshal(doc, out)
}

func trongenProxyUnmarshalValue(doc []byte, v {{.TronPrefix}}Value, out any) error {
	return tronjson.UnmarshalValue(doc, v, out)
}
{{end}}
